---
sidebar_position: 6
title: Modelagem de Dados
description: "" 
---

# Modelagem de Dados

:::info[Aula em ElaboraÃ§Ã£o]
Infelizmente eu ainda nÃ£o terminei esse material. VocÃª pode aproveitar para ir vendo os outros conteÃºdos enquanto isso! ðŸ˜œ
:::

## Projeto de Banco de Dados

### Fundamentos de Banco de Dados

#### Abordagem de Arquivos x Banco de Dados

Podemos definir um **banco de dados** como:
> Uma coleÃ§Ã£o de dados relacionados, persistentes[^1] \[...\] que tem por objetivo atender uma comunidade de usuÃ¡rios.

[^1]: Ou seja, que continuam salvos mesmo depois do computador desligar.

Dessa feita, podemos ver que *antes* de modelar e projetar nosso banco, temos que ter em mentos o propÃ³sito de uso e sua real necessidade.

Outro conceito muito prÃ³ximo Ã© o de **Sistema Gerenciador de Banco de Dados (SGBD):**
> Um software que incorpora as funÃ§Ãµes de definiÃ§Ãµes, recuperaÃ§Ã£o e alteraÃ§Ã£o de dados em um BD

Ou seja, **Banco de dados** Ã© um conceito com foco no **conteÃºdo**. Enquanto, **SGBD** Ã© um conceito com foco na **tecnologia** que vai manipular o conteÃºdo armazenado (ex: MySQL, MSSQL, Firebird e etc).

##### O Passado
Mas nem sempre existiu a abordagem de banco de dados. Antigamente, cada programa precisava ser responsÃ¡vel pelos prÃ³prios arquivos que persistiam as informaÃ§Ãµes. 

O modo de persistir dados era com **enfoque de arquivos**. Onde meio que tudo era salvo em plain text ou algum formato de texto estruturado como um `csv` da vida e os sistemas tinham que trabalhar com isso.

Desse modo, era praticamente impossÃ­vel intercambiar informaÃ§Ãµes entre aplicaÃ§Ãµes porque nÃ£o se tinha um template geral para consulta e persistÃªncia dos dados.

Isso gerava a necessidade de cada aplicaÃ§Ã£o ter sua prÃ³pria base (mesmo que a informaÃ§Ã£o fosse comum Ã  vÃ¡rios setores). Agora, imagine que existam 3 tabelas `produto` e que o valor de venda dele foi alterado. Existe uma chance real que algum time simplesmente esqueÃ§a de atualizar em uma das rÃ©plicas o que poderia causa graves prejuÃ­zos Ã  empresa.

#### Tipos de Linguagens e Tipos de Profissionais

##### Linguagens DDL E DML

JÃ¡ vimos que um banco de dados Ã© relacionado ao conteÃºdo que serÃ¡ persistido para consulta posterior. Dessa feita, como tudo em tecnologia, precisamos de uma `linguagem` para interagir com o SGBD afim de criarmos as definiÃ§Ãµes dos dados e manipular o que tivermos salvo.

Existem 2 tipos de linguagens que usamos para essa tarefa:
- **DDL (Data Definition Language)**: Usada para criar tabelas, criar visÃµes, definir relaÃ§Ãµes entre elas e as caracterÃ­sticas de cada valor.
- **DML (Data Manipulation Language)**: Muito mais usada na prÃ¡tica diÃ¡ria. Ã‰ responsÃ¡vel por manipular (select, insert, delete, update) os dados persistidos. Pode ser de 2 tipos.
	- **Procedural**: Onde o user define qual dado serÃ¡ acessado e como chegar nele. Mais usados em triggers e rotinas automÃ¡ticas.
	- **NÃ£o Procedural**: Onde define apenas qual dado acessar.

:::note[ComentÃ¡rio]
Ao longo dos estudos vamos nos deparar com um conceito chamado `stored procedure` e Ã© exatamente isso que acabamos de ver acima.
:::

Para aprofundar um pouco mais, abaixo temos dois exemplos de DML.

```sql
/* DML Procedural */
BEGIN
  DECLARE @EmployeeName VARCHAR(50);
  DECLARE @EmployeeId INT = 101;
  
  SELECT @EmployeeName = Name
  FROM Employees
  WHERE EmployeeID = @EmployeeId;
  
  PRINT @EmployeeName;
END;
```

```sql
/* DML NÃ£o Procedural */
SELECT Name
FROM Employees
WHERE EmployeeID = 101;
```

Podemos ver que na DML nÃ£o procedural, deixamos a cargo do motor da linguagem julgar qual melhor rota para acessar as informaÃ§Ãµes que solicitamos[^2].

[^2]: Na esperanÃ§a que ele sempre tome uma decisÃ£o otimizada de como acessar o dado. Mas fique tranquilo, quase sempre ele escolhe o melhor caminho.

##### Principais atuantes em um projeto de BD

Como papÃ©is principais em um projeto de banco de dados, podemos destacar:
- Administrador de Dados (AD)
	- Arquiteta a estrutura de informaÃ§Ã£o da empresa
	- Administra a descriÃ§Ã£o da base de dados[^3]
	- Define padrÃµes de codificaÃ§Ã£o (template de nome de tabela, campos e etc)
	- Profundo conhecedor das regras de negÃ³cio
- Administrador de Banco de Dados (DBA)
	- Foco na otimizaÃ§Ã£o e performance
	- Gerencia o SGBD
	- Ã‰ responsÃ¡vel pela estrutura de armazenamento (migrations, carga de dados e etc)
- Analista de Sistemas/Engenheiro de Software/Desenvolvedor
	- ConstrÃ³i soluÃ§Ãµes que consomem o SGBD
	- Deve procurar otimizar suas `queries` de modo a sempre custar pouco para o processamento do SGBD
- UsuÃ¡rio Final
	- Podem ser tanto no nÃ­vel operacional quanto gerencial

[^3]: TambÃ©m conhecido como dicionÃ¡rio de dados.

#### NÃ­veis do SGBD e Etapas do Projeto de BD

#### NÃ­veis do SGBD

Um SGBD pode ser divido em 3 nÃ­veis de abstraÃ§Ã£o:

1. **NÃ­vel Interno/FÃ­sico**
	- AtuaÃ§Ã£o do DBA com foco no **como** os dados sÃ£o armazenados em disco e como melhorar a **performance** de acesso aos mesmos.
2. **NÃ­vel Conceitual/LÃ³gico**
	- AtuaÃ§Ã£o do DA com foco em **quais** dados sÃ£o salvos no BD e seus relacionamentos.
3. **NÃ­vel Externo/VisÃ£o**
	- AtuaÃ§Ã£o de Devs e Users com objetivo de **acessar** os dados disponÃ­veis. Sempre sendo necessÃ¡rio apenas uma parte do todo.

:::info[Info]
Abaixo temos dois conceitos derivados desses que acabamos de ver. Hoje em dia, podem parecer simples mas, no passado, a separaÃ§Ã£o entre camadas fÃ­sicas e lÃ³gicas eram bem menor do que hoje em dia.
:::

> **IndependÃªncia FÃ­sica**: Quando alteraÃ§Ãµes na camada fÃ­sica nÃ£o impactam a camada lÃ³gica.[^4]

> **IndependÃªncia LÃ³gica**: Quando alteraÃ§Ãµes na camada lÃ³gica nÃ£o impactam a camada fÃ­sica.

[^4]: Por exemplo, trocar o SGBD do MSSQL para MySQL. Em tese, Ã© possÃ­vel realizar essa migraÃ§Ã£o sem alterar a estrutura das tabelas visto que ambos sÃ£o do tipo SQL.

##### Etapas de um Projeto de BD

Tal qual as etapas, durante a elaboraÃ§Ã£o de um projeto de BD temos um estudo para cada camada, ou seja:

1. **Projeto Conceitual**
	- Foco na informaÃ§Ã£o, independente da implementaÃ§Ã£o do SGBD.
	- DefiniÃ§Ã£o dos tipos e das relaÃ§Ãµes.
	- CriaÃ§Ã£o dos Modelos de Entidade-Relacionamento (MER).
1. **Projeto LÃ³gico**
	- AdaptaÃ§Ã£o do projeto conceitual ao SGBD.
	- ConversÃ£o dos modelos de dados ao tipo especÃ­fico de SGBD (SQL, NoSQL, Redes e etc).
	- Ã‰ nessa etapa que temos a definiÃ§Ã£o das tabelas, relaÃ§Ãµes de campos e chaves.
1. **Projeto FÃ­sico**
	- ImplementaÃ§Ã£o real no hardware.
	- Quanto de recursos precisarÃ£o ser alocados bem como as polÃ­ticas de backup.
	- CriaÃ§Ã£o dos Perfis de acesso.

### Modelagem de Entidades e Relacionamentos (MER)

#### Modelagem de Entidades e Atributos

Agora que sabemos os profissionais e os tipos de projetos de banco de dados, vamos entrar na teoria sobre a modelagem de dados propriamente dita.

> Podemos conceituar a **Modelagem de Dados** como a conversÃ£o de fatos relevantes em *estruturas bem definidas* com *regras de dependÃªncia* expressas em um *modelo grÃ¡fico e descritivo*.

O foco aqui Ã© em **quais** dados existirÃ£o no banco de dados, independente de **como** eles serÃ£o armazenados no SGBD.

Um dos modelos conceituais[^5] mais usados Ã© o **Modelo Entidade-Relacionamento (MER)**. Essa tÃ©cnica permite demonstrar facilmente a relaÃ§Ã£o descrita acima por meio de representaÃ§Ãµes grÃ¡ficas simples entre as entidades.

[^5]: Ou seja, estamos ainda na etapa de um projeto conceitual.

##### Diferentes tipos de notaÃ§Ã£o

No material didÃ¡tico dessa disciplina usamos a notaÃ§Ã£o de Peter Chen como base. Entretanto, eu tenho um motor de geraÃ§Ã£o de diagramas nativo na biblioteca que uso para construir esse site que segue a notaÃ§Ã£o de [James Martin](https://www.conceptdraw.com/examples/the-crow%E2%80%99s-foot-erd).

:::warning[AtenÃ§Ã£o]
A notaÃ§Ã£o de James Martin tem alguns apelidos como "IE Notation" ou ainda "Crow's Foot Notation".
:::

O importante Ã© sempre entender a lÃ³gica geral. Nesse [artigo da wikipÃ©dia](https://en.wikipedia.org/wiki/Entity%E2%80%93relationship_model) temos um exemplo de como podemos mostrar uma mesma relaÃ§Ã£o de diferentes modos.

![diferentes-ER](../img/94-modelos-er.png)

:::tip[Dica]
Existem vÃ¡rias ferramentas para escrever esses tipos de diagramas. Aqui, eu vou usar a `Mermaid` [Link da documentaÃ§Ã£o](https://mermaid.js.org/syntax/entityRelationshipDiagram.html).
:::

##### Entidades e Atributos no MER

> **Entidades** sÃ£o objetos do mundo real ou abstraÃ§Ãµes de informaÃ§Ã£o.

> **Atributos** sÃ£o elementos que identificam as entidades e descrevem suas caracterÃ­sticas.

Atributos podem ser de vÃ¡rios tipo, para nomear alguns:
 - Simples: CPF, Altura, PreÃ§o.
 - Compostos: Compostos por partes, como Telefone = PaÃ­s + DDD + Numero.
 - Monovalorados: Recebem 1 valor por entidade.
 - Multivalorados: VÃ¡rios valores por entidade.
 - Derivados: IMC que Ã© uma funÃ§Ã£o da altura e peso.
 - Chave: Valores distintos que podem ser usados para identificar as entidades.

Abaixo eu coloco um exemplo de entidade no modelo Crow's foot onde podemos ver que os atributos sÃ£o definidos por tipo, nome e se Ã© primary key no prÃ³prio retÃ¢ngulo da entidade. Na notaÃ§Ã£o de Chen eles sÃ£o elipses ligadas Ã  entidade.

```mermaid
erDiagram
	CLIENTE {
		int id PK
		string nome
		float altura
		float peso
	}
	
```

Para simplificar nosso material, eu vou omitir nas entidades os atributos sempre que possÃ­vel assim cada entidade vai ser representada apenas por um retÃ¢ngulo com o nome. Mas lembre-se que na hora de fazer um MER de verdade as entidades devem estar sempre com seus atributos.

#### Modelagem de Relacionamentos

Alguns conceitos importantes para a modelagem de relacionamentos:

> **Relacionamento** Ã© qualquer associaÃ§Ã£o com significado entre uma ou vÃ¡rias entidades

> **Cardinalidade** Ã© a propriedade do relacionamento que expressa a quantidade de ocorrÃªncias. Por exemplo, 1-1, 1-n, n-n e etc.

> **Totalidade** Ã© a especificaÃ§Ã£o da condiÃ§Ã£o de existÃªncia entre classes de modo que uma sÃ³ pode existir se o relacionamento com outra existe. Pode ser **parcial/opcional** ou **total/obrigatÃ³ria**[^6].

[^6]: Pense no exemplo de um colÃ©gio infantil. O cadastro `responsavel_aluno` sÃ³ pode existir se o cadastro anterior `aluno` jÃ¡ existir. Agora se for uma instituiÃ§Ã£o superior de ensino, que possui alunos maiores de 18 anos, esse campo pode ser opcional apenas para alunos menores de idade.

:::note[ComentÃ¡rio]
NÃ£o sei vocÃª, mas, pra mim "totalidade total" Ã© um nome bem ruim pra um conceito. Dessa feita, vou usar o termo "totalidade obrigatÃ³ria" sempre que for me referir a essa propriedade.
:::

```mermaid
erDiagram
    DEPARTAMENTO 1--0+ EMPREGADO : ""
```

NÃ³s lemos esse diagrama acima da seguinte forma: Um departamento pode possuir entre 0 a N empregados. Similarmente, qualquer empregado sÃ³ pode pertencer a um Ãºnico departamento.

Mais um exemplo dado no curso:

```mermaid
erDiagram
    DEPARTAMENTO 1--0+ MATERIA : ""
    MATERIA 1--0+ TURMA : ""
    TURMA 1--0+ ALUNO : ""
```

Nesse segundo exemplo nÃ³s temos um esquema bÃ¡sico de uma faculdade. Podemos ver que um `departamento` pode ofertar N `materias` e essas matÃ©rias podem ser ofertada em N `turmas`. Um aluno, por sua vez, sÃ³ pode pertencer a 1 Ãºnico curso.

#### Modelo de Entidades e Relacionamentos Estendido

#### Entidades Fracas e Relacionamentos MÃºltiplos

AtÃ© agora jÃ¡ sabemos mostrar entidades, suas propriedades e suas relaÃ§Ãµes com outras entidades. Agora vamos aprimorar mais um pouco nosso modelo representativo adicionando hierarquia entre entidades.

> **Entidade Fraca**: Ã‰ toda entidade que nÃ£o tem chave prÃ³pria, ou seja, precisa ser identificada por meio de um relacionamento com outra entidade (que Ã© forte pois possui chave) e por um identificador fraco (chave parcial).

> **Relacionamentos Estendidos**: SÃ£o os relacionamentos entre mais de duas entidades (chamados de relacionamentos binÃ¡rios).

Abaixo temos um exemplo de entidade fraca chamada `transacao`. Chamamos ela de entidade fraca porque ela precisa das chaves estrangeiras das contas para fazer sentido.

```mermaid
erDiagram
    CONTA {
        int numero_conta PK
    }
    TRANSACAO {
        int numero_conta_entrada FK
        int numero_conta_saida FK
        date data
        float quantia
    }
    CONTA 1--1+ TRANSACAO : ""
```

Agora vamos ver um exemplo mais complexo onde temos relacionamentos nÃ£o binÃ¡rios.

```mermaid
erDiagram
	FUNCIONARIO {
		int matricula PK
		string nome
	}
	DEPARTAMENTO {
		int codigo PK
		string nome
	}
	CIDADE {
		string CEP PK
		int numero PK
		int capacidade
	}
	FUNCIONARIO 0+--1 CIDADE : ""
	FUNCIONARIO 0+--1 DEPARTAMENTO : ""
```

Aqui podemos ver que um registro de funcionÃ¡rio precisa indicar tanto a cidade quanto o departamento para que seja possÃ­vel saber sua lotaÃ§Ã£o.

##### Atributos de Relacionamentos

Na notaÃ§Ã£o de Peter Chen tambÃ©m Ã© possÃ­vel derivar atributos dos relacionamentos igual fazemos com as entidades. A ideia Ã© evidenciar quais dados surgem a partir da relaÃ§Ã£o entre entidades.

> **Atributos de Relacionamentos**: SÃ£o atributos derivados da associaÃ§Ã£o entre entidades e nÃ£o sÃ£o oriundos das entidades per se.

:::danger[Aviso]
Essa derivaÃ§Ã£o de atributos para relacionamentos sÃ³ Ã© encontrada no modelo de Chen. Dessa feita, vemos que a tendÃªncia  do mercado Ã© alocar esses atributos diretamente a uma classe.
:::

Um exemplo de atributo de relacionamento pode ser encontrado na imagem abaixo.

![atributo-relacionamento](../img/95-atributo-relacionamento.png)

Veja que o relacionamento `OPOS` tem um atributo diretamente nele. Mas isso causa uma certa dificuldade quando vamos pensar nas tabelas do SGBD pois temos que definir **onde** esse atributo do relacionamento serÃ¡ salvo.

#### Modelagem de Supertipos e Subtipos

Algo comum de se deparar na construÃ§Ã£o de um modelo de banco de dados Ã© relaÃ§Ãµes de **hierarquia** entre as entidades. Desse modo, precisamos evoluir nosso modelo representativo para indicar classes gerais e classes especÃ­ficas.

:::note[ComentÃ¡rio]
Essa Ã© justamente a discussÃ£o que vimos na matÃ©ria de [ProgramaÃ§Ã£o Modular](./04-programacao-modular.md).
:::

> **GeneralizaÃ§Ã£o**: Atributos de uma classe genÃ©rica/superclasse/supertipo que indica atributos comuns a uma gama de outras entidades.

> **EspecializaÃ§Ã£o**: Processo de definir em detalhes uma classe genÃ©rica adaptando-a em casos mais concretos.

Na declaraÃ§Ã£o de subtipos, devemos investigar como os tipos derivados podem ser classificados entre si.

> Para os casos onde uma entidade sÃ³ pode ser de um subtipo[^7] usamos o termo **disjunÃ§Ã£o**. 

> Para os casos onde podem haver mais de uma relaÃ§Ã£o[^8] usamos o termo **sobreposiÃ§Ã£o**.

[^7]: Por exemplo, se um atleta de futebol Ã© goleiro, ele nÃ£o pode ser atacante.
[^8]: Por exemplo, um funcionÃ¡rio de um banco pode ser, tambÃ©m, um cliente do mesmo banco.

Outra relaÃ§Ã£o importante de se definir Ã© se a superclasse **precisa** ser definida em termos de subclasse. 

> Se a classe geral tiver uso sem uma especializaÃ§Ã£o, usamos o conceito de **subtipo total**. 

> Caso ela tenha uso mesmo sendo classe geral mas permita uma especializaÃ§Ã£o, dizemos que ela Ã© **subtipo parcial**.

:::danger[Aviso]
Essa parte de subtipo e supertipo com classes total ou parcialmente separadas tambÃ©m sÃ³ existe no modelo de Chen. Com o tempo, o mercado foi percebendo que "menos Ã© mais" e tendeu para modelos que sÃ£o mais fÃ¡ceis de ler e entregam um resultado parecido em termos de compreensÃ£o.
:::

Abaixo temos um diagrama que reflete a mesma ideia do pertencimento parcial usando o diagrama de Crow's foot mas lembre-se que isso Ã© apenas para efeito didÃ¡tico.

```mermaid
erDiagram
	FUNCIONARIO {
		string cpf PK
		string nome
		datetime data_nascimento
		string endereco
		int tipo_emprego
		int cod_lotacao
	}
	SECRETARIA {
		int anos_de_estudo
	}
	TECNICO {
		int anos_na_empresa
		int falhas_mapeadas
	}
	ENGENHEIRO {
		int area_formacao
		int projetos_aprovados
	}
	FUNCIONARIO 1--0+ DISJUNCAO : "Completude Parcial"
	DISJUNCAO 1--0+ SECRETARIA : ""
	DISJUNCAO 1--0+ TECNICO : ""
	DISJUNCAO 1--0+ ENGENHEIRO : ""
```

O diagrama acima Ã© uma aproximaÃ§Ã£o de como o modelo de Chen trata a especificaÃ§Ã£o das classes. A ideia Ã© evidenciar que, dado um funcionÃ¡rio, ele sÃ³ pode ser de um Ãºnico subtipo ou do tipo genÃ©rico.

Em outras palavras, podemos ter um registro de funcionÃ¡rio genÃ©rico mas, tambÃ©m, especificado entre as outras 3 categorias.

Agora vamos ver um exemplo de completude total onde a especificaÃ§Ã£o se torna obrigatÃ³ria.

```mermaid
erDiagram
	VEICULO {
		int ID PK
		float preco
		string placa
	}
	CARRO {
		string marca
		int numero_passageiros
	}
	CAMINHAO {
		string marca
		int eixos
		float capacidade
	}

	VEICULO 1--1+ DISJUNCAO : "Completude Total"
	DISJUNCAO 1--0+ CARRO : ""
	DISJUNCAO 1--0+ CAMINHAO : ""
```

Nesse exemplo de uma concessionÃ¡ria de veÃ­culos, vemos que, dado um veÃ­culo, ele tem que pertencer obrigatoriamente hÃ¡ uma subcategoria.

Para encerrar essa parte, vamos ver um exemplo usando sobreposiÃ§Ã£o ao invÃ©s de disjunÃ§Ã£o. No caso, modelamos o cenÃ¡rio de uma indÃºstria que precisa controlar um insumo produtivo que pode vir tanto do seu estoque quanto do fornecedor.

```mermaid
erDiagram
	INSUMO {
		int ID
		string NOME
	}
	ESTOQUE {
		int ID
		float QTD
		float PRECO_MEDIO
	}
	FORNECEDOR {
		int ID
		float PRECO
		string EMAIL
	}
	
	INSUMO 1--1+ SOBREPOSICAO : "Completude Total"	
	SOBREPOSICAO 1--0+ ESTOQUE : ""
	SOBREPOSICAO 1--0+ FORNECEDOR : ""
```



## Projeto de Banco de Dados Relacionais e NÃ£o Relacionais

### Modelo Relacional de Banco de Dados

Surgiu em meados da dÃ©cada de 70 por E.F. Codd como uma definiÃ§Ã£o puramente derivada da teoria de conjuntos da matemÃ¡tica.

Em 1974, a IBM tentou implementar atravÃ©s do [Sistema R](https://people.eecs.berkeley.edu/~brewer/cs262/SystemR.pdf) o primeiro SGBD capaz de usar a, entÃ£o novidade, **Linguagem de Consulta Estruturada** ou **Structured Query Language (SQL)** para recuperaÃ§Ã£o de dados.

#### Conceitos do Modelo Relacional e Chave PrimÃ¡ria

Agora vamos levantar alguns conceitos chaves do modelo relacional.

> **RelaÃ§Ã£o** Ã© qualquer tabela de valores onde cada linha representa uma relaÃ§Ã£o de valores relacionados a uma mesma entidade. Por isso o nome do modelo Ã© Modelo Relacional.

> **Tupla** sÃ£o as linhas de uma relaÃ§Ã£o (linhas na tabela) que sÃ£o obrigatoriamente distintas entre si.

> **Atributo** sÃ£o o cabeÃ§alho de cada coluna, tambÃ©m chamado de **campo da tabela**. A quantidade de atributos[^9] define o grau da relaÃ§Ã£o.

[^9]: Por exemplo, uma tabela `pessoa` com 2 colunas: `nome` e `idade`. Ã‰ dita como sendo uma relaÃ§Ã£o de grau 2.

> Chamamos de **DomÃ­nio** qualquer conjunto de valores vÃ¡lidos[^10] para um atributo.

[^10]: Para explicar melhor esse conceito, podemos pensar em uma tabela que tenha a coluna `grau_de_instrucao`. Ela sÃ³ pode aceitar um valor string dentro da lista \[`fundamental`, `medio`, `superior`\]. Essa lista de opÃ§Ãµes Ã© o **domÃ­nio** do atributo `grau_de_instrucao`.

:::warning[AtenÃ§Ã£o]
NÃ£o podemos confundir **DomÃ­nio** com **Tipo FÃ­sico** do atributo. Tipo fÃ­sico Ã© relacionado ao modo como a variÃ¡vel Ã© salva no hardware (ex: `string`, `int`, `float` e etc). DomÃ­nio Ã© a lista de valores aceitos no atributo.
:::

Aqui temos um exemplo de implementaÃ§Ã£o de domÃ­nio na prÃ¡tica

```sql
CREATE TABLE Funcionarios (
	Nome VARCHAR(100) NOT NULL, 
	Idade INT NOT NULL CHECK (Idade BETWEEN 18 AND 65), 
	Departamento VARCHAR(50) NOT NULL CHECK (Departamento IN ('RH', 'TI', 'Financeiro')) 
);
```


AlÃ©m dos conceitos acima, existem algumas regras que o modelo relacional adota implicitamente que sÃ£o importante de se ter em mente:
- Os valores dos atributos sÃ£o **atÃ´micos** ou seja, sÃ³ existe 1 endereÃ§o para cada intersecÃ§Ã£o linha-coluna.
-  No modelo relacional se admite o valor **nulo** que nÃ£o Ã© igual Ã  string vazia ou zero.

Para encerrar, podemos definir uma dada relaÃ§Ã£o $R(A_1, A_2, ..., A_n)$ onde $R$ Ã© o nome da relaÃ§Ã£o, $A_i$ Ã© o nome do atributo, $n$ Ã© o grau da relaÃ§Ã£o.

Os dados dentro da relaÃ§Ã£o sÃ£o as tuplas definidas por $r(R)$ de modo que $r = \{t_1, t_2, ..., t_n\}$.

##### Chave PrimÃ¡ria

> A **Chave PrimÃ¡ria** Ã© a coluna (ou combinaÃ§Ã£o delas) que define de maneira cabal a distinÃ§Ã£o entre entidades em uma dada tabela.


#### Integridade Referencial e Chave Estrangeira

### Mapeamento do Modelo de Entidades e Relacionamentos para Modelo Relacional

#### Mapeamento de Entidades e Atributos

#### Mapeamento de Relacionamentos

### NormalizaÃ§Ã£o de Banco de Dados

#### Primeira e Segunda Formas Normais

#### Terceira Forma Normal

### Banco de Dados NÃ£o-Relacionais

#### Database NoSQL

### SeguranÃ§a

#### SeguranÃ§a de Banco de Dados

## Bibliografia

- ELMASRI, Ramez; NAVATHE, Shamkant B. **Sistemas de banco de dados.** 7 ed. SÃ£o Paulo: Person, 2018. 
- MARTIN, James. **Principles of Data Base Management**.
- CHEN, Peter. **Modelagem de dados: A abordagem para Projeto LÃ³gico**.
- E.F. Codd. **A Relational Model of Data For Large Shared Data Banks**. Comm. ACM 13, 6 (June 1970), 377-387.